---
title: "TCR Sharing - Notebook"
format:
  html: 
    theme: flatly
    toc: true
    toc_depth: 3
    code-fold: true # show
    #embed-resources: true
    number-sections: true
    smooth-scroll: true
    grid:
      body-width: 1000px
      margin-width: 300px
jupyter: python3 # "Python3.9.6"
# /usr/bin/python3 -m venv ~/venvs/quarto-env
# source ~/venvs/quarto-env/bin/activate
# pip install --upgrade pip
# pip install logomaker scipy seaborn pandas matplotlib plotly jupyter ipykernel pyyaml
# python -m ipykernel install --user --name python3.9.6 --display-name "Python3.9.6"
#
# source ~/venvs/quarto-env/bin/activate
# quarto preview /Users/kmlanderos/Documents/Johns_Hopkins/Karchin_Lab/Projects/TCRtoolkit/TCRtoolkit-Bulk/notebooks/compare_sharing_report.qmd --no-browser --no-watch-inputs
---

Thank you for using TCRtoolkit! This report is generated from sample data and metadata you provided. The report is divided into two sections: 

@sec-report-setup : Code to setup the report. This section includes the parameters you used to run the pipeline, loading necessary packages, data, etc.   
@sec-Analysis: Analysis of TCRtoolkit pipeline reults  
    @sec-sharing: TCR sharing between samples.  
    @sec-GLIPH2: Grouping of TCRs (TCRB CDR3) by paratope hotspots using GLIPH2 

# Report Setup {#sec-report-setup}

```{python, echo=false}
#| tags: [parameters]
#| echo: false

## 1. Pipeline Parameters
#Default inputs are overwritten at the command line in `modules/local/plot_sample.nf`
from pathlib import Path
workflow_cmd = "nextflow run main.nf --data_dir test_data/minimal-example     --samplesheet test_data/minimal-example/samplesheet.csv     --output out-minimal-dev     --max_memory 10GB --max_cpus 4"
project_name = "TCRtoolkit-Bulk"
project_dir = "/Users/kmlanderos/Documents/Johns_Hopkins/Karchin_Lab/Projects/TCRtoolkit/"
cluster_details_csv = "/Users/kmlanderos/Documents/Johns_Hopkins/Karchin_Lab/Projects/TCRtoolkit/TCRtoolkit-Bulk/out-minimal-dev/gliph2/cluster_member_details.txt"
clone_network_csv = "/Users/kmlanderos/Documents/Johns_Hopkins/Karchin_Lab/Projects/TCRtoolkit/TCRtoolkit-Bulk/out-minimal-dev/gliph2/clone_network.txt"
all_motifs_csv = "/Users/kmlanderos/Documents/Johns_Hopkins/Karchin_Lab/Projects/TCRtoolkit/TCRtoolkit-Bulk/out-minimal-dev/gliph2/all_motifs.txt"
global_similarities_csv = "/Users/kmlanderos/Documents/Johns_Hopkins/Karchin_Lab/Projects/TCRtoolkit/TCRtoolkit-Bulk/out-minimal-dev/gliph2/global_similarities.txt"
local_similarities_csv = "/Users/kmlanderos/Documents/Johns_Hopkins/Karchin_Lab/Projects/TCRtoolkit/TCRtoolkit-Bulk/out-minimal-dev/gliph2/local_similarities.txt"
convergence_groups_csv = "/Users/kmlanderos/Documents/Johns_Hopkins/Karchin_Lab/Projects/TCRtoolkit/TCRtoolkit-Bulk/out-minimal-dev/gliph2/convergence_groups.txt"
pgen_csv = "/Users/kmlanderos/Documents/Johns_Hopkins/Karchin_Lab/Projects/TCRtoolkit/TCRtoolkit-Bulk/out-minimal-dev/tcrsharing/cdr3_sharing_pgen.tsv"
```

```{python}
#| tags: [setup]
#| warning: false

# 1. Load Packages
import pandas as pd
import logomaker

# 2. Print pipeline parameters
print(f"Project Name:          {project_name}")
print(f"Workflow command:      {workflow_cmd}")
print(f"Pipeline Directory:    {project_dir}")

# 3. Loading data
cluster_details = pd.read_csv(cluster_details_csv, sep='\t')
clone_network = pd.read_csv(clone_network_csv, sep='\t', header=None)
all_motifs = pd.read_csv(all_motifs_csv, sep='\t')
global_similarities = pd.read_csv(global_similarities_csv, sep='\t')
local_similarities = pd.read_csv(local_similarities_csv, sep='\t')
convergence_groups = pd.read_csv(convergence_groups_csv, sep='\t')
prob_generation_df = pd.read_csv(pgen_csv, sep='\t')
```

# Analysis {#sec-Analysis}

# TCR Sharing / TCR Publicity {#sec-sharing}  

**TCR publicity** refers to how widely a specific T-cell receptor (TCR) sequence is shared among different individuals. In simple terms, it's a **measure of whether a TCR is unique to one person or common across a population.**

**<u>Private vs. Public TCRs ðŸ‘¥</u>**   

**Private TCRs:** These receptor sequences are found in only one individual. The vast majority of a person's TCR repertoire is private, reflecting their unique genetic background and history of antigen exposure.

**Public TCRs:** These are identical TCR sequences found in multiple, unrelated individuals. **While much rarer than private TCRs, these shared receptors are often of great biological importance.**

```{python}

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import io

# --- Histogram Code ---

# Set the figure size
plt.figure(figsize=(8, 6))

# Define bins to center bars on integer values
# It creates bins like [0.5, 1.5, 2.5, ...]
max_sharing = prob_generation_df['total_samples'].max()
bins = np.arange(0.5, max_sharing + 1.5, 1)

# Create the histogram
plt.hist(prob_generation_df['total_samples'], bins=bins, edgecolor='black')

# Set the y-axis to a logarithmic scale
plt.yscale('log')

# Add titles and labels
plt.title('TCR Sharing Histogram', fontsize=16)
plt.xlabel('Number of Shared Samples', fontsize=12)
plt.ylabel('TCR Sequence Frequency (log scale)', fontsize=12)

# Ensure x-axis ticks are integers
plt.xticks(range(1, max_sharing + 1))
plt.show()

```

**Figure 1. TCR sharing histogram.** Number of samples where a TCR has an exact match on the aminoacid level. 

This histogram gives you an immediate sense of the immune landscape. A cohort exposed to a common antigen (like a widespread virus or a shared environmental factor) may show a larger-than-expected public repertoire (higher bars for x > 1). **It helps answer the general question: "How similar are the T-cell repertoires among the individuals in this study?"**  

```{python}

# NOTE: This code should be in Compare (N-way)

import pandas as pd
import numpy as np
from io import StringIO
import itertools

# --- Import HoloViews and set up the Bokeh backend ---
# Installation: pip install holoviews bokeh
import holoviews as hv
from holoviews import opts
hv.extension('bokeh')
# --- NEW: Import HoverTool for custom tooltips and a color mapper ---
from bokeh.models import HoverTool
from bokeh.transform import linear_cmap
from bokeh.palettes import Viridis256

# --- 1. Data Processing ---
concat_cdr3='/Users/kmlanderos/Documents/Johns_Hopkins/Karchin_Lab/Projects/TCRtoolkit/TCRtoolkit-Bulk/out-minimal-dev/compare/concatenated_cdr3.txt'
clonotypes_df = pd.read_csv(concat_cdr3, sep='\t', header=0, index_col=0).reset_index()
df = clonotypes_df.copy()

# Filter for TCRs shared across 2 or more unique samples
df_counts = df.groupby('CDR3b').filter(lambda x: x['sample'].nunique() > 1)
sample_names = sorted(df['sample'].unique())
num_samples = len(sample_names)

# --- Matrix for Chord WIDTH (based on clone counts) ---
adjacency_matrix = pd.DataFrame(np.zeros((num_samples, num_samples)),
                                index=sample_names,
                                columns=sample_names)
# --- Matrix for Node COLOR (based on number of shared clones) ---
clone_count_matrix = pd.DataFrame(np.zeros((num_samples, num_samples)),
                                  index=sample_names,
                                  columns=sample_names)

grouped = df_counts.groupby('CDR3b')

# Calculate the weighted connections AND the number of shared clones
for name, group in grouped:
    for sample1, sample2 in itertools.combinations(group['sample'], 2):
        # For width: sum of counts
        count1 = group.loc[group['sample'] == sample1, 'counts'].iloc[0]
        count2 = group.loc[group['sample'] == sample2, 'counts'].iloc[0]
        shared_value = count1 + count2
        adjacency_matrix.loc[sample1, sample2] += shared_value
        adjacency_matrix.loc[sample2, sample1] += shared_value
        
        # For color: number of clones
        clone_count_matrix.loc[sample1, sample2] += 1
        clone_count_matrix.loc[sample2, sample1] += 1

# --- 2. Visualization: Generate the Chord Diagram with HoloViews ---

# Calculate total shared clones per sample for coloring
total_shared_clones = clone_count_matrix.sum(axis=1)

# --- NEW: Identify and filter out samples that share no TCRs ---
sharing_samples = total_shared_clones[total_shared_clones > 0].index.tolist()
adjacency_matrix_filt = adjacency_matrix.loc[sharing_samples, sharing_samples]

# Apply logarithmic transformation to the connection values for chord width
adjacency_matrix_log = adjacency_matrix_filt.apply(np.log1p)

# --- Convert data to a format HoloViews prefers (Edge List) ---
adj_stacked = adjacency_matrix_log.stack().reset_index()
adj_stacked.columns = ['source_name', 'target_name', 'value']
links_df = adj_stacked[(adj_stacked['value'] > 0) & (adj_stacked['source_name'] != adj_stacked['target_name'])].copy()

# Map the string names to integer indices using only the filtered samples
name_to_idx = {name: i for i, name in enumerate(sharing_samples)}
links_df['source'] = links_df['source_name'].map(name_to_idx)
links_df['target'] = links_df['target_name'].map(name_to_idx)

# --- NEW: Create the "nodes" DataFrame with the new column name and filtered data ---
nodes_df = pd.DataFrame({'name': sharing_samples})
nodes_df['TCRs_shared'] = nodes_df['name'].map(total_shared_clones) # Rename column
nodes_dataset = hv.Dataset(nodes_df, 'index')

# Convert the links DataFrame to a HoloViews Dataset
links_dataset = hv.Dataset(links_df, kdims=['source', 'target'], vdims='value')

# --- NEW: Define custom hover tool ---
# This removes the "index" field and uses the new column name.
hover = HoverTool(tooltips=[
    ('Sample', '@name'),
    ('TCRs Shared', '@TCRs_shared')
])

# Create the HoloViews Chord object
chord_diagram = hv.Chord((links_dataset, nodes_dataset))

# Apply visualization options with new color mapping and hover tool
chord_diagram.opts(
    opts.Chord(
        node_color='TCRs_shared',   # Color nodes by the 'TCRs_shared' column
        cmap='Reds',             # Use a continuous colormap
        edge_color='source',        # Color edges by the value of the source node
        labels='name',
        title="Interactive TCR Sharing (Color by # Shared Clones)",
        height=600,
        width=600,
        node_size=15,
        tools=[hover],              # Apply the custom hover tool
        edge_line_width=hv.dim('value').norm()*10
    )
)
chord_diagram

```

**Figure 2. TCR sharing Circos plot.**  

```{python}

import pandas as pd
import plotly.graph_objects as go
import io

def create_top_shared_clones_table(df, n_top_clones=10):
    """
    Creates an interactive Plotly table showing the top N most shared TCR clones.

    Args:
        df (pd.DataFrame): DataFrame with TCR data, requiring 'total_samples',
                           'CDR3b', and 'pgen' columns.
        n_top_clones (int): The number of top clones to display.
    """
    # --- 1. Sort the DataFrame and select the top N clones ---
    # Sort by the number of samples a clone is shared in, descending.
    top_clones_df = df.sort_values(by='total_samples', ascending=False).head(n_top_clones)

    # --- 2. Prepare the data for display ---
    # Select and rename columns for a clean presentation
    display_df = top_clones_df[['CDR3b', 'total_samples', 'pgen', 'samples_present']].copy()
    display_df.rename(columns={
        'CDR3b': 'CDR3b Sequence',
        'total_samples': '# Shared Samples',
        'pgen': 'Generation Probability',
        'samples_present': 'Present In Samples'
    }, inplace=True)
    
    # Format the probability into scientific notation for readability
    display_df['Generation Probability'] = display_df['Generation Probability'].apply(lambda x: f"{x:.2e}")

    # --- 3. Create the Plotly Table Figure ---
    fig = go.Figure(data=[go.Table(
        header=dict(
            values=list(display_df.columns),
            fill_color='paleturquoise',
            align='left',
            font=dict(size=14, color='black'),
            line_color='darkslategray'
        ),
        cells=dict(
            values=[display_df[col] for col in display_df.columns],
            fill_color='lavender',
            align='left',
            font=dict(size=12, color='black'),
            line_color='darkslategray',
            height=30 # Adjust cell height for spacing
        )
    )])

    # --- 4. Update the layout with a centered title ---
    fig.update_layout(
        title_text=f"Top {n_top_clones} Most Shared TCR Clones",
        title_x=0.5, # Center the title
        margin=dict(l=10, r=10, t=50, b=10)
    )
    
    return fig

# Generate and display the table
top_clones_table_fig = create_top_shared_clones_table(prob_generation_df, n_top_clones=10)
top_clones_table_fig.show()

```

**Table 1. Top 10 most shared TCR clones** Public TCRs order by number of samples they are seen.


**<u>Why TCR Publicity is Important?</u>**  
**The primary reason public TCRs are important is convergent selection.** The generation of TCRs is a random process, and the potential diversity is astronomical. Therefore, **if the exact same TCR sequence appears in many different people, it's highly unlikely to be by chance. Instead, it strongly implies that different immune systems, when faced with the same threat** (like a virus or cancer cell), have independently "converged" on the same optimal TCR as an effective weapon.

```{python}

# --- Scatter Plot Code ---

# # Set the figure size
plt.figure(figsize=(10, 7))

# Calculate the log10 of the generation probability
log_pgen = np.log10(prob_generation_df['pgen'])

# Create the scatter plot
plt.scatter(log_pgen, prob_generation_df['total_samples'], color='blue', alpha=0.6)

# Add titles and labels
plt.title('Scatterplot of Shared TCRs vs log10(Generation Probability)', fontsize=16)
plt.xlabel('log10(Probability)', fontsize=12)
plt.ylabel('Number of Shared Samples', fontsize=12)

# Add a grid for better readability
plt.grid(True)

# Set y-axis ticks to be integers
plt.yticks(range(1, prob_generation_df['total_samples'].max() + 1))

plt.show()

```

**Figure 3. TCR sharing and generation probability correlation** Relationship between the likelihood of a T-cell receptor (TCR) being generated (generation probability, Pgen) and the number of samples it is shared across.  

**<u>How to Interpret the scatter plot?</u>**  

**The General Trend:** You will notice that points on the right (higher Pgen, "easier-to-make" TCRs) tend to have higher y-values (more sharing). This is expected; **if a TCR sequence is easy to generate, it's more likely to appear in multiple people just by chance.**

**The Key Insight (Upper-Left Quadrant):** The most biologically significant points are those that defy this trend. Pay close attention to the TCRs in the upper-left area of the plot. These are **TCRs with a very low generation probability (they are rare and hard to make) that are nevertheless shared across multiple samples.**

## GLIPH2: TCRB CDR3 motif clusters visualization {#sec-GLIPH2}

**GLIPH2** (Grouping of Lymphocyte Interactions by Paratope Hotspots, version 2) is a computational tool used in TCR sequence analysis to **identify clusters of TCRs that likely recognize the same or similar antigens**.  

By grouping TCRs with shared sequence motifs, particularly in the CDR3 regions (the main antigen-binding region), GLIPH2 helps infer functional relationships and **predict which TCRs might target the same or related epitopes**.

For the current stage of analysis, we are focusing solely on the **CDR3 region of the TCR beta chain (TCRB)**. a network was created to facilitate result visualization.

**GLIPH2 classifies specificity groups in two categories.** The color of each cluster tells you whether the shared motif is **local** (motif-based), meaning that motifsâ€™ position within CDR3 are restricted within 3 amino acids. Or **global**, where member CDR3s need to be of the same length, and differ at the same position.

```{python}
import pandas as pd
import igraph as ig
import plotly.graph_objs as go
import plotly.express as px
import matplotlib.pyplot as plt

# Ensure correct column names
clone_network.columns = ["source", "target", "type", "group"]

# Remove singleton edges
clone_network = clone_network[clone_network['type'] != 'singleton']

# Build graph from edgelist
edges = clone_network[["source", "target"]].values.tolist()
g = ig.Graph.TupleList(edges, directed=False)

# Create node-to-group and node-to-type mappings from both columns
group_df = pd.concat([
    clone_network[['source', 'group']].rename(columns={'source': 'node'}),
    clone_network[['target', 'group']].rename(columns={'target': 'node'})
]).drop_duplicates()

type_df = pd.concat([
    clone_network[['source', 'type']].rename(columns={'source': 'node'}),
    clone_network[['target', 'type']].rename(columns={'target': 'node'})
]).drop_duplicates()

group_dict = group_df.set_index('node')['group'].to_dict()
type_dict = type_df.set_index('node')['type'].to_dict()

# Assign node attributes
g.vs['group'] = [group_dict.get(v['name'], 'NA') for v in g.vs]
g.vs['type'] = [type_dict.get(v['name'], 'NA') for v in g.vs]

# Layout
layout = g.layout("fr")
coords = list(map(tuple, layout))

# Edge trace (just one for all edges)
edge_x = []
edge_y = []
for edge in g.es:
    src, tgt = edge.tuple
    x0, y0 = coords[src]
    x1, y1 = coords[tgt]
    edge_x += [x0, x1, None]
    edge_y += [y0, y1, None]

edge_trace = go.Scatter(
    x=edge_x, y=edge_y,
    line=dict(width=0.5, color='#888'),
    hoverinfo='none',
    mode='lines',
    name='',  # No legend entry
)

# Color palette for categorical types
type_list = sorted(set(g.vs['type']))
color_map = {t: c for t, c in zip(type_list, px.colors.qualitative.Set2)}

# Node traces (one per type)
node_traces = []
for t in type_list:
    indices = [i for i, v in enumerate(g.vs) if v['type'] == t]
    node_x = [coords[i][0] for i in indices]
    node_y = [coords[i][1] for i in indices]
    hover_text = [
        f"{g.vs[i]['name']}<br>Group: {g.vs[i]['group']}<br>Type: {g.vs[i]['type']}"
        for i in indices
    ]
    node_trace = go.Scatter(
        x=node_x, y=node_y,
        mode='markers',
        name=t,
        hoverinfo='text',
        text=hover_text,
        marker=dict(
            color=color_map[t],
            size=10,
            line_width=2
        )
    )
    node_traces.append(node_trace)

# Final figure
fig = go.Figure(data=[edge_trace] + node_traces,
                layout=go.Layout(
                    title='TCRB CDR3 Motif Network',
                    showlegend=True,
                    hovermode='closest',
                    margin=dict(b=20, l=5, r=5, t=40),
                    xaxis=dict(showgrid=False, zeroline=False),
                    yaxis=dict(showgrid=False, zeroline=False))
)

# Save or show
fig.show()

```

**Figure 4. Specificity groups across patients** Each circle (node) represents a unique TCR clonotype across all data. Nodes are connectionected if they share a common sequence motif, placing them into the same specificity group. 



**<u>How to Extract Biological Knowledge from the Figure?</u>**  

1. Are there large, dense clusters?
A large cluster containing many connected nodes signifies a convergent immune response. This means that multiple different T-cell lineages have independently evolved to recognize the same target, implying a strong and focused immune pressure against a specific antigen.

2. Are the most prominent clusters driven by Local or Global motifs?  

3. What are the specific motifs in the key clusters?
Hover over the nodes within a large, local (orange) cluster to identify the shared sequence motif (e.g., CASSINQPQHF). You can take this motif sequence and:


```{python}
# Calculate motif lengths
all_motifs["motif_length"] = all_motifs["motif"].str.len()

# Count how many motifs of each length
length_counts = all_motifs["motif_length"].value_counts().reset_index()
length_counts.columns = ["motif_length", "count"]
length_counts = length_counts.sort_values("motif_length")

# Plot bar chart
plt.figure(figsize=(8, 5))
plt.bar(length_counts["motif_length"], length_counts["count"],
        color="darkgreen", edgecolor="black")

plt.title("Motif Length Distribution")
plt.xlabel("Motif Length")
plt.ylabel("Number of Motifs")
plt.xticks(length_counts["motif_length"])
plt.grid(axis='y', linestyle='--', alpha=0.5)
plt.tight_layout()
plt.show()

```

**Figure 5. TCRB CDR3 motif lengths** 

Knowing the length of the amino acid motifs is useful because it provides insight into both the biological plausibility of the findings and the likely functional relationship between the clustered T-cells.

**<u>Reflecting the Biophysics of Binding</u>**  
From a biological standpoint, **the interaction between a TCR and its target peptide-MHC is often driven by a small number of critical "contact points" or "hotspots" within the CDR3 loop.** These hotspots typically consist of a short stretch of 2-5 amino acids. When GLIPH2 identifies a large number of **motifs with a length of 3 or 4**, it serves as a crucial sanity check. It suggests the algorithm **is not just finding random statistical noise, but is successfully identifying patterns that are biologically plausible** and reflect the known mechanics of T-cell recognition.

**<u>Short Motifs (2-3 amino acids):</u>** These are like a broad. They are **more likely to occur by chance** and may define more "promiscuous" groups of TCRs that share a common structural feature but might still bind to a range of similar peptides.

**<u>Long Motifs (4-5 amino acids):</u>** These are like a specific. They are statistically much rarer and impose a much stronger constraint on the TCR's structure. Therefore, a group of TCRs defined **by a longer motif is very **likely to be highly specific for the exact same antigen.

```{python}
#| label: fig-motif-interactive-plotly

import pandas as pd
import numpy as np
import plotly.graph_objects as go

def create_interactive_motif_plot(all_motifs):
    """
    Creates an interactive bar plot of top TCR motifs with a dropdown menu
    to select the motif length. Suitable for Quarto HTML output.
    """
        
    # --- 2. Prepare the data ---
    # Calculate motif length
    all_motifs['motif_length'] = all_motifs['motif'].str.len()
    
    # Filter out any rows where motif or its length is NaN
    all_motifs.dropna(subset=['motif', 'motif_length'], inplace=True)
    
    # Ensure the length column is an integer
    all_motifs['motif_length'] = all_motifs['motif_length'].astype(int)
    
    # Get the unique lengths to create a dropdown option for each
    unique_lengths = sorted(all_motifs['motif_length'].unique())

    # --- 3. Create the Plotly Figure ---
    fig = go.Figure()

    # --- 4. Process each motif length and add a trace ---
    for i, length in enumerate(unique_lengths):
        # a. Filter data for the current length
        df_by_length = all_motifs[all_motifs['motif_length'] == length]

        # b. Select top 10 motifs for that specific length
        top10 = df_by_length.sort_values("num_in_sample", ascending=False).head(10)

        # c. Determine visibility (only the first trace is visible initially)
        is_visible = (i == 0)

        # d. Add a bar trace for the current length
        fig.add_trace(
            go.Bar(
                x=top10["motif"],
                y=top10["num_in_sample"],
                name=f"Length {length}",
                visible=is_visible,
                marker_color='tomato',
                marker_line_color='black',
                marker_line_width=1.5
            )
        )

    # --- 5. Create the dropdown menu ---
    buttons = []
    for i, length in enumerate(unique_lengths):
        # Create a visibility mask. It's a list of booleans as long as the number of traces.
        visibility_mask = [False] * len(unique_lengths)
        visibility_mask[i] = True # Set only the current trace to visible

        button = dict(
            label=f"Length {length}",
            method="update",
            args=[
                {"visible": visibility_mask},
                {"title": f"Top 10 Motifs of Length {length} by TCR Members"}
            ]
        )
        buttons.append(button)

    # --- 6. Update the figure layout with the dropdown ---
    initial_title = "Top 10 Motifs by TCR Members"
    if unique_lengths:
        initial_title = f"Top 10 Motifs of Length {unique_lengths[0]} by TCR Members"

    fig.update_layout(
        updatemenus=[
            dict(
                active=0,
                buttons=buttons,
                direction="down",
                pad={"r": 10, "t": 10},
                showactive=True,
                x=0.01,
                xanchor="left",
                y=1.15,
                yanchor="top"
            )
        ],
        title_text=initial_title,
        xaxis_title="Motif",
        yaxis_title="Number of TCRs",
        font=dict(size=12)
    )
    
    fig.show()

# --- Run the function to generate the plot ---
create_interactive_motif_plot(all_motifs)

```
**Figure 6. Top 10 TCR specificity motifs ranked by member count.** 
Bar chart displaying the most prevalent amino acid motifs identified by the GLIPH2 algorithm, ranked by the number of unique T-cell receptors (TCRs) that share each motif. 

This bar chart ranks the top conserved amino acid motifs found by GLIPH2 based on the number of unique T-cell receptors (TCRs) that belong to each specificity group. Each bar represents a specific motif (e.g., 'GG'), and its height indicates the size of that "TCR neighborhood"â€”the total number of different TCRs that share this core binding pattern.   

Identifying the motifs shared by the largest number of unique TCRs helps **pinpoint the most immunodominant recognition strategies used by the T-cells** in your dataset; you are effectively highlighting the **most common solutions the immune system has evolved to target key antigens**, thus providing a data-driven way to prioritize the most significant TCR communities for further study. However, it is crucial to interpret these findings with care, as **the most frequent motifs are often short and may not always define the most functionally specific T-cell groups compared to smaller groups with longer, more complex motifs.**


## GLIPH2 global Motifs  
GLIPH2 identifies TCRB CDR3 clusters based on either local motifs (short, position-restricted patterns within 3 amino acids) or **global similarity (requiring identical CDR3 length and differences at the same positions).** Visualizing global motifs as sequence logos reveals the conserved amino acid preferences at each position, and can provide insights into the sequence features that potentially drive shared antigen recognition.

Logo visualization of the top 10 global motifs based on no. TCR members

```{python}
# Sort and select top 10 motifs by cluster_size
top10 = global_similarities.sort_values("cluster_size", ascending=False).head(10).copy()

# Loop through each motif
for i, row in top10.iterrows():
    motif_name = f"Motif {row['cluster_tag']}; nTCRs: {row['cluster_size']}"

    # Split and clean CDR3b sequences
    seqs = [s.strip() for s in str(row["CDR3b"]).split(" ") if s.strip()]

    # Only plot if there are at least 2 sequences
    if len(seqs) >= 2:
        # Create a counts matrix from aligned sequences
        try:
            counts_mat = logomaker.alignment_to_matrix(seqs, to_type="probability")

            # Plot
            plt.figure(figsize=(10, 3))
            logo = logomaker.Logo(counts_mat)
            plt.title(motif_name)
            plt.tight_layout()
            plt.show()
        except Exception as e:
            print(f"Could not plot motif {row['cluster_tag']}: {e}")
```


